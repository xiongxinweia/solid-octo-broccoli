# 容器数据卷

[toc]

> 卷就是目录或者文件，存在于一个或者多个容器中，有docker挂载到容器，但不属于联合文件系统，因此能逃过Union file system 提供的一些持续存储或者共享数据的特性
>
> **卷的设计目的就是数据持久化，完全独立于容器的生存周期，因此docker不会在容器删除时删除其挂载的数据卷**



**有点类似于redis中的rdb和aof文件**

> RDB文件
> 1、RDB文件用于保存和还原Redis服务器所有数据库中的所有键值对数据
> 2、SAVE命令由服务器进程直接执行保存操作，该命令会阻塞服务器
> 3、BGSAVE命令由子进程执行保存操作，不会阻塞服务器
> 注意此时服务器的状态：在处理BGSAVE命令时，服务器处理SAVE、BGSAVE、BGREWRITEAOF三个命令方式与平时不同。
>
> 客户端发送的SAVE命令会被服务器拒绝，服务器禁止SAVE命令与BGSAVE同时执行，是为了避免父进程与子进程同时执行rdbSave调用，产生竞争条件。
> 客户端发送的BGSAVE命令也会被服务器拒绝，因为同时执行两个BGSAVE也会产生竞争条件。
> 最后：BGSAVE和BGREWRITEAOF不能同时执行：因为两个命令实际工作都是由子进程执行，所以两个命令在操作方面没有冲突，但是并发出两个子进程，并且两个子进程都是同时执行大量的磁盘写入操作的话不是个好主意。
> 4、服务器状态中会保存所有用save选项设置的保存条件，当任意一个保存条件被满足，服务器自动执行BGSAVE
> 5、RDB文件时一个经过压缩的二进制文件，由多个部分组成
> 6、对于不同类型的键值对，RDB文件会使用不同方式保存
>
> AOF文件
> 1、APF文件通过保存所有修改数据库的写命令请求来记录服务器的数据库状态
> 2、AOF文件中的所有命令都是以Redis命令请求协议的格式保存的
> 3、命令请求会先保存到AOF缓冲区中，之后再定期写入并同步到AOF文件
> 4、appendfsync选项的不同值对于AOF持久化功能的安全性以及Redis服务器的性能有很大影响
>
> 当appendfsync的值为always时，服务器在每个事件循环都要将aof_buf缓冲区中的所有内容写到AOF文件中，并且同步AOF文件，所以always的效率最慢，但安全性最强，出现故障，AOF持久化也只会丢失一个事件循环中所产生的命令数据
> 当appendfsync的值为everysec时，服务器在每个事件循环都要将aof_buf缓冲区中的所有内容写入到AOF文件，并且每隔一秒就要在子线程中对AOF文件进行一次同步。效率足够快，出现故障也只会丢失一秒钟的命令数据
> 当appendfsync的值为no时，服务器在每个事件循环都要将aof_buf缓冲区中的所有内容写入到AOF文件中，何是同步由操作系统控制。该模式下的AOF文件写入速度最快，因为缓存了足够多的数据，但是出现故障会丢失上次同步AOF之后的所有写命令数据
> 5、服务器只要载入并重新执行保存在AOF文件中的命令，就可以还原数据库本来的状态（通过创建一个不带网络连接的伪客户端）
> 6、AOF重写可以产生一个新的AOF文件，新文件与原有文件所保存的数据库状态一样，但是体积更小
> 7、AOF重写的功能时通过读取数据库中的键值对来实现的，程序无须对现有AOF文件进行任何读入、分析或者写入操作
> 8、执行BGREWRITEAOF命令时，Redis服务器会维护一个AOF重写缓冲区，该缓冲区会在子进程创建新AOF文件期间，记录服务器执行的所有写命令。当子进程完成创建新AOF文件的工作之后，服务器会将重写缓冲区中的所有内容追加到新AOF文件的末尾，使得新旧两个AOF文件所保存的数据库状态一致。最后，服务器用新的AOF文件替换掉旧AOF文件，完成文件重写操作

**==可以将docker容器中的数据保存到宿主机的磁盘中==**



**运行一个带容器卷存储功能的容器实例**

**特点：**

+ 数据卷可在容器之间共享或重用数据
+ 卷中的更改可以直接生效。爽（实时）
+ 数据卷中的更改不会包含在镜像的更新中
+ 数据卷的生命周期一直此需要没有容器使用它为止

> cp需要手动拷贝，而容器卷可以实时拷贝





### 容器卷和主机互联互通

### 如何运行

```
docker run -it --privileged=true -v /宿主机绝对路径目录：/容器内目录   镜像名称
```

> 宿主机的绝对路径映射到容器类的目录

**`-v`：可以指定多个路径**

```bash
root@ubuntu:/etc/v2ray# docker images
REPOSITORY                                         TAG       IMAGE ID       CREATED        SIZE
smile/myubuntu                                     1.0.0     b52dbe11bca0   18 hours ago   231MB
registry.cn-hangzhou.aliyuncs.com/nsddd/myubuntu   latest    6962da3091d1   19 hours ago   108MB
tomcat                                             latest    fb5657adc892   4 months ago   680MB
redis                                              latest    7614ae9453d1   4 months ago   113MB
python                                             latest    a5d7930b60cc   4 months ago   917MB
v2fly/v2fly-core                                   latest    9fb39a47a148   5 months ago   53.4MB
registry                                           latest    b8604a3fe854   5 months ago   26.2MB
ubuntu                                             latest    ba6acccedd29   6 months ago   72.8MB
root@ubuntu:/etc/v2ray# docker ps
CONTAINER ID   IMAGE              COMMAND                  CREATED         STATUS                         PORTS     NAMES
f19e7fbc3d18   v2fly/v2fly-core   "/usr/bin/v2ray -con…"   8 minutes ago   Restarting (2) 3 seconds ago             tcp
root@ubuntu:/etc/v2ray# docker run -it --privileged=true -v /tmp/host_data:/tmp/docker_data --name=u1 ubuntu
root@37d9f24e95a3:/# cd /tmp/docker_data/
root@37d9f24e95a3:/tmp/docker_data# ls
root@37d9f24e95a3:/tmp/docker_data# mkdir a && touch a.txt b.txt
root@37d9f24e95a3:/tmp/docker_data# ls
a  a.txt  b.txt
root@37d9f24e95a3:/tmp/docker_data# root@ubuntu:/etc/v2ray# cd /tmp/host_data/ && ls
a  a.txt  b.txt
root@ubuntu:/tmp/host_data# touch zhuji.txt && ls
a  a.txt  b.txt  zhuji.txt
root@ubuntu:/tmp/host_data# docker ps
CONTAINER ID   IMAGE              COMMAND                  CREATED          STATUS                          PORTS     NAMES
37d9f24e95a3   ubuntu             "bash"                   2 minutes ago    Up 2 minutes                              u1
f19e7fbc3d18   v2fly/v2fly-core   "/usr/bin/v2ray -con…"   13 minutes ago   Restarting (2) 14 seconds ago             tcp
root@ubuntu:/tmp/host_data# docker exec -it 37d9f24e95a3 /bin/bash
root@37d9f24e95a3:/# cd /tmp/docker_data/ && ls
a  a.txt  b.txt  zhuji.txt
```

**由此可见，同步回来了，这样对于开发者来说特别方便**



### 查看容器卷是否挂载成功

```
docker inspect 容器id
```

**我们看mounts（挂载)下面的json字符串**

```json
        "Mounts": [
            {
                "Type": "bind",
                "Source": "/tmp/host_data",
                "Destination": "/tmp/docker_data",
                "Mode": "",
                "RW": true,
                "Propagation": "rprivate"
            }
        ],
```

+ source使指宿主机路径
+ destination是指目的容器的路径



### 特殊情况下的互联互通

```
docker stop 容器id
```

**我们停止容器id后，此时在主机上创建一个文件，如果此时恢复容器后，会不会同步**

**答案：会**

> 因为是双线的同步



### 了解容器卷的读写规则和映射的添加说明

+ 只读（默认）
+ 只写

```
docker run -it --privileged=true -v /宿主机绝对路径目录：/容器内目录   镜像名称
```

**上面的命令相当于是在容器后面加了`:rw`，是可以读可以写的，我们可以设置为只读或者只写**

##### 1. 设置为只读

```
docker run -it --privileged=true -v /宿主机绝对路径目录：/容器内目录:ro   镜像名称
```

**`ro`:read only**

**此时如果宿主机写入内容，可以同步给容器，容器自己只能读入不能写**



##### 2.设置为只写

```
docker run -it --privileged=true -v /宿主机绝对路径目录：/容器内目录:wo   镜像名称
```



### 卷的继承和共享

```
docker run -it --privileged=true --volumes-from u1 --name u2 ubuntu
```

**u2继承u1**

**此时如果u1没了，那么u2依旧可以和主机数据共享**

> 薪火相传>>>>

**1. 新建Ubuntu2继承ubuntu1**

```bash
root@ubuntu:/tmp/host_data# docker ps
CONTAINER ID   IMAGE              COMMAND                  CREATED          STATUS                          PORTS     NAMES
37d9f24e95a3   ubuntu             "bash"                   31 minutes ago   Up 31 minutes                             u1
f19e7fbc3d18   v2fly/v2fly-core   "/usr/bin/v2ray -con…"   41 minutes ago   Restarting (2) 54 seconds ago             tcp
root@ubuntu:/tmp/host_data# docker run -it --privileged=true --volumes-from 37d9f24e95a3  --name ubuntu2 ubuntu
root@c6b2169449f4:/# cd /tmp/docker_data/
root@c6b2169449f4:/tmp/docker_data# ls
a  a.txt  aa.txt  b.txt  zhuji.txt
root@c6b2169449f4:/tmp/docker_data# touch ubuntu2.txt && mkdir ubuntu2
root@c6b2169449f4:/tmp/docker_data# ls
a  a.txt  aa.txt  b.txt  ubuntu2  ubuntu2.txt  zhuji.txt
```



**2. 查看ubuntu1**

```shell
root@37d9f24e95a3:/tmp/docker_data# ls
a  a.txt  aa.txt  b.txt  ubuntu2  ubuntu2.txt  zhuji.txt
root@37d9f24e95a3:/tmp/docker_data# mkdir ubuntu1 && touch ubuntu2.t
root@37d9f24e95a3:/tmp/docker_data# ls
a  a.txt  aa.txt  b.txt  ubuntu1  ubuntu2  ubuntu2.txt  zhuji.txt
```



**3. 查看主机**

```shell
root@c6b2169449f4:/tmp/docker_data# ls
a  a.txt  aa.txt  b.txt  ubuntu1  ubuntu2  ubuntu2.txt  zhuji.txt
root@c6b2169449f4:/tmp/docker_data# root@ubuntu:/tmp/host_data# 
root@ubuntu:/tmp/host_data# ls
a  aa.txt  a.txt  b.txt  ubuntu1  ubuntu2  ubuntu2.txt  zhuji.txt
```



