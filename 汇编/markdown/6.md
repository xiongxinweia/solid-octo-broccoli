+ [author](https://github.com/3293172751)

# 第6节 内存的分段管理法

+ [回到目录](../README.md)
+ [回到项目首页](../../README.md)
+ [上一节](5.md)
> ❤️💕💕汇编语言目前仍在发挥着不可替代的作用，在效率上无可替代，在底层，学习linux内核，计算机外围设备和驱动，都离不开汇编。Myblog:[http://nsddd.top](http://nsddd.top/)
---
[TOC]

## 8086的分段管理

**8086使用`物理地址=段地址×16+偏移地址`的方式给出内存单元的物理地址。**

+ **内存并没有分段，段的划分来自于CPU**



#### 基本概念1

1. 寄存器是微处理器内部暂存数据的存储单元，以名称表示
2. 存储器则是微处理器外部存放程序及其数据的空间
3. 程序及其数据可以长久存放在外存，在程序需要时才进入主存(外存中数据需要先被读入内存再被CPU处理)



#### 基本概念2

1. 主存需要利用地址区别
2. 存储单元: 每个存储单元都有一个编号；被称为存储器地址
3. 存储内容: 每个存储单元存放一个字节的内容
4. 如0002H单元存放有一个数据34H表达为：[0002H]＝34H(中括号括起来的表示地址)



#### 基本概念3

1. 二进制位Bit, 字节Byte, 字Word(16位，2个字节), 双字DWord(32位，4个字节)
2. 多字节数据存放时，低字节存入低地址，高字节存入高地址；
   表达时，用它的低地址表示多字节数据占据的地址空间。
   例如在下图中，2号“字”单元的内容为：[0002H] = 1234H; 2号“双字”单元的内容为：[0002H] = 78561234H;

3. 由此也可以看出，同一个存储器地址可以是字节单元地址、字单元地址、双字单元地址等等




### 存储器的分段管理

8086CPU有20条地址线，最大可寻址空间为220＝1MB，物理地址范围从00000H～FFFFFH。而8086寄存器最大是16位的，显然一个寄存器不能确定某一内存单元的20位物理地址

于是，8086CPU将1MB空间分成许多逻辑段（Segment）。分段就是硬件限制下的产物，在32位或64位寄存器的情况下，段寄存器的作用已经越来越不明显了

- 将内存空间分为很多段，**用一个寄存器表示某段在内存空间内的起始地址(段地址)，用另一个寄存器表示段内某内存单元相对于本段起始地址的距离(偏移地址)，用两个16位的寄存器就可以形成20位地址**
- **每个段最大限制为64KB=2^16^ 使得偏移量可以放到一个16位寄存器中**
- 对最小的段没有限制，可定义只包含一个字节的段
- 而段基址必须定位在地址为16的整数倍上



## 8086PC机存储单元表示

> **数据在`21F60H`内存单元中，段地址是`2000H`**，说法：
>
> + 数据存在内存`2000H:1F60H`单元中（常用）
>   + `2000H`:段地址
>   + `1F60H`:偏移地址
> + 数据存在内存的`2000H`段中的`1F60H`单元中

**段地址很重要！！！ ----   用专门的寄存器存放段地址**

四个段地址寄存器

1. CS - 代码段寄存器
2. DS - 数据段寄存器
3. SS - 栈段寄存器
4. ES - 附加段寄存器

**偏移地址可以用多种方式提供  --  8086丰富的取址方式**

## END 链接

+ [回到目录](../README.md)
+ [上一节](5.md)
+ [下一节](7.md)
---
+ [参与贡献❤️💕💕](https://github.com/3293172751/Block_Chain/blob/master/Git/git-contributor.md)