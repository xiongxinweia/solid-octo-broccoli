+ [author](https://github.com/3293172751)
# 第21节 mul乘法指令
+ [回到目录](../README.md)
+ [回到项目首页](../../README.md)
+ [上一节](20.md)
> ❤️💕💕汇编语言目前仍在发挥着不可替代的作用，在效率上无可替代，在底层，学习linux内核，计算机外围设备和驱动，都离不开汇编。Myblog:[http://nsddd.top](http://nsddd.top/)
---
[TOC]

## div指令（除法指令）

|                |      |                        |
| -------------- | ---- | ---------------------- |
| 被除数         | 32位 | 16位                   |
| 除数           | 16位 | 8位                    |
| 被除数存放位置 | AX   | AX（低8位）DX（高8位） |

**div**是除法指令，使用**div**做除法的时候应注意一下问题：

  1）除数：有8位和16位两种，在一个reg（寄存器）或内存单元中。

  2）被除数：默认放在**AX**或**DX和AX**中，如果除数为8位，被除数则为16位，默认存放在 **AX**中存放；如果除数为16位，被除数则为32位，在**DX和AX**中存放， **DX**存放高16位， **AX**存放低16位。

  3）结果：如果除数为8位，则**AL**存储除法操作的商， **AH**存储除法操作的余数；如果除数为16位，则 **AX**存储除法操作的商，**DX**存储除法操作的余数。

div格式：

```assembly
div reg

div 内存单元
```

例：

```assembly
div byte ptr ds:[0]

含义：（al）= (ax) / ((ds) * 16 + 0)的商
      (ah) = (ax) / ((ds) * 16 + 0)的余数


div word ptr es:[0]

含义： (ax) = [(dx * 10000H) + (ax)] / ((es) * 16 + 0) 的商
      (dx) = [(dx * 10000H) + (ax)] / ((es) * 16 + 0) 的余数


div byte ptr [bx + si + 8]

含义: (al) = (ax) / [(ds) * 16 + (bx) + (si) + 8] 的商
	（ah）= (ax) / [(ds) * 16 + (bx) + (si) + 8] 的余数
 

div word ptr [bx + si + 8]

含义:  (ax) = [(dx) * 10000H + (ax)] / [(ds) * 16 + bx + si + 8] 的商
	  (dx) = [(dx) * 10000H + (ax)] / [(ds) * 16 + bx + si + 8] 的余数 
```

**编程：利用除法指令计算100001/100**

  1）被除数100001大于65535，不能用**ax**寄存器存放，只能用**dx** 和 **ax**联合存放，即16位除法。

  2）除数100小于255，可以用一个8位寄存器存放，但是，因为被除数是32位的，除数应为16位，所以要用一个16位寄存器来存放除数100。

  3）100001表示为16进制为186A1H,因为要分为高位和低位存放。

实现：

```
mov dx, 1     //或 10000H

mov ax, 86A1H    //(dx) * 10000H + ax = 100001  

mov bx, 100

div bx
```

**编程：利用除法指令计算1001/100**

 1)1001可以用ax存放，100可以用8位寄存器存放，所以进行8位除法。

实现：

```
mov ax, 1001

mov bl, 100

div bl
```

## mul指令（乘法指令）

mul乘法指令：

 1）两个相乘的数，两个相乘的数，要么都是8位，要么都是16位。

+ 如果是8位，一个默认放在AL中，另一个放在8位reg或内存单元中。

+ 如果是16位，一个默认在AX中，另一个放在16位的reg或内存单元中。

 2）结果：如果是8位乘法，结果默认放在AX中，结果高位默认放在DX中存放，低位在AX中放。

> 对于小于`255`的数，可以用八位也可以用十六位，但是对于我们来说用八位就够了。

**mul格式：**

```
mul reg

mul 内存单元
```

例：

```assembly
mul byte ptr ds：[0]
含义：（ax） = (al) * ((ds) * 16 + 0)
mul word ptr [bx + si + 8]

含义：
	（ax）= (ax) * ((ds) * 16 + (bx) + (si) + 8) //结果的低16位
	（dx）= (ax) * ((ds) * 16 + (bx) + (si) + 8) //结果的高16位
```

例：计算100 * 10

100 和 10小于255，可以做8位乘法。

```
mov al, 100

mov bl, 10

mul bl
```

结果：(ax) = 1000

例：计算100 * 10000

100小于255，但是10000大于255必须做16乘法。

```
mov ax, 10000

mov bx, 100

mul bx
```

结果：（ax）= 4240H （dx）= 000FH （F4240H = 1000000）





## 用mul做乘法

**格式：**

```
mul 寄存器
mul 内存单元
```



### 示例程序

8位乘法，100 * 2

```assembly
mov al,100	;八位
mov bl,2
mul bl
```

**结果：（ax) = 1000(03E8H)**



16位乘法，100 * 10000

```assembly
mov ax,100	;十六位
mov bx,10000
mul bx
```

**结果：(dx) = 000FH , (ax) = 4340H**

+ dx放乘以后的高16位
+ ax放乘以后的低16位



## END 链接

+ [回到目录](../README.md)
+ [上一节](20.md)
+ [下一节](22.md)
---
+ [参与贡献❤️💕💕](https://github.com/3293172751/Block_Chain/blob/master/Git/git-contributor.md)